<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>S7plc EPICS driver</title>
<meta content="iso-8859-1" http-equiv="charset">
<meta name="author" content="Dirk Zimoch">
</head>
<body>
<h1>S7plc EPICS driver documentation</h1>
<p>
This driver was written to connect a Siemens S7 PLC (programmable
logic controller) via ethernet to an EPICS IOC. However, it can be used for any
device sending and receiving blocks of process variables (PVs) in the same way.
</p>
<p>
The driver was originally developped for SLS (Swiss Light Source) in 2000. Later
is has been modified by DESY (Deutsches Elektronen Synchrotron). The current
version has been largely rewritten for PPT (Puls-Plasmatechnik GmbH) to run on
EPICS 3.14.6. Current author is
<a href="mailto:Dirk Zimoch <dirk.zimoch&#64;psi&#46;ch>">Dirk Zimoch</a>.
</p>
<p>
In this document, it is assumed that the reader is familiar with EPICS, the
record concept and meanings of the fields of the standard records.
Recommended documentation: EPICS Record Refecrence Manual.
</p>
<h2>1 Driver Configuration</h2>
<p>
In the IOC startup script, the s7plc driver needs to be configured:
<pre>
s7plcConfigure <i>name</i>, <i>bigEndian</i>
</pre>
</p>
<p>
<tt><i>name</i></tt> is a symbolic name for the connection. The records
reference the connection with this name.
</p>
<p>
<tt><i>bigEndian</i></tt> is <tt>1</tt> or <tt>0</tt> if the byte order of the
process variables in the PLC (i.e. in the transmitted data blocks) is big endian (motorola format)
or little endian (intel format) respectively. The byte order of the IOC machine
is automatically detected.
</p>

<h2>2 Device Support</h2>
<p>
The driver supports the standard record types <a href="#ai">ai</a>,
<a href="#ao">ao</a>, <a href="#bi">bi</a>, <a href="#bo">bo</a>,
<a href="#mbbi">mbbi</a>, <a href="#mbbo">mbbo</a>,
<a href="#mbbiDirect">mbbiDirect</a>, <a href="#mbboDirect">mbboDirect</a>,
<a href="#longin">longin</a>, <a href="#longout">longout</a>,
<a href="#stringin">stringin</a>, <a href="#stringout">stringout</a>,
and <a href="#waveform">waveform</a>. The <tt>DTYP</tt> is "S7plc". If the
record processes when the PLC is not connected (off, down, unreachable), the
record raises INVALID_ALARM with status CONN_ALARM.
</p>
<p>
There is also a connection status support for <a href="#stat">bi</a>. The
<tt>DTYP</tt> is "S7plc&nbsp;stat". This record does not raise an alarm when
the PLC is disconnected. It just returns 0 in that case.
</p>
<p>
The general form of the <tt>INP</tt> or <tt>OUT</tt> link is
</p>
<pre>
  "@<i>name</i>: <i>station_number</i>/<i>offset</i> T=<i>type</i> L=<i>low</i> L=<i>high</i> B=<i>bit</i>"
</pre>
<p>
Not all parameters <tt>T</tt>, <tt>L</tt>, <tt>H</tt>, and <tt>B</tt> are
required for each record type and parameters equal to the default value may
be omitted. The default values depend on the record type.
</p>
<p>
<tt><i>name</i></tt> is the connection name as defined in the
<tt>s7plcConfigure</tt> call in the startup script.
</p>
<p>
<tt><i>station_number</i></tt> is an integer number refering to a PLC on the
connection. The first PLC has number 0.
</p>
<p>
<tt><i>offset</i></tt> is the byte offset of the PV relative to the beginning
of the input or output data block for this PLC. It is an integer number or
a sum of integer numbers like <tt>20+3+2</tt>.
</p>
<p>
<tt>T=<i>type</i></tt> defines the data type for transmitting the PV from or
to the PLC:
<ul>
<a name="type">
<table border=1>
<tr>
<th>T=</th><th>Data Type</th><th>Default L=</th><th>Default H=</th>
</tr>
<tr>
<td>INT8</td><td>8 bit (1 byte) signed integer number</td>
    <td>-0x7F</td><td>0x7F</td>
</tr>
<tr>
<td>UINT8<br>UNSIGN8</td><td>8 bit (1 byte) unsigned integer number</td>
    <td>0x00</td><td>0xFF</td>
</tr>
<tr>
<td>INT16</td><td>16 bit (2 bytes) signed integer number</td>
    <td>-0x7FFF</td><td>0x7FFF</td>
</tr>
<tr>
<td>UINT16<br>UNSIGN16</td><td>16 bit (2 bytes) unsigned integer number</td>
    <td>0x0000</td><td>0xFFFF</td>
</tr>
<tr>
<td>INT32</td><td>32 bit (4 bytes) signed integer number</td>
    <td>-0x7FFFFFFF</td><td>0x7FFFFFFF</td>
</tr>
<tr>
<td>UINT32<br>UNSIGN32</td><td>32 bit (4 bytes) unsigned integer number</td>
    <td>0x00000000</td><td>0xFFFFFFFF</td>
</tr>
<tr>
<td>FLOAT</td><td>32 bit (4 bytes) floating point number</td>
</tr>
<tr>
<td>DOUBLE</td><td>64 bit (8 bytes) floating point number</td>
</tr>
<tr>
<td>STRING</td><td>character array</td>
    <td>40</td>
</tr>
</table>
<W/a>
</ul>
The default is <tt>T=INT16</tt> for most record types.
</p>
<p>
<tt>L=<i>low</i></tt> and <tt>H=<i>high</i></tt> are used in analog input and
output records when the analog value is converted to an integer value.
They define the raw values which convert to <tt>EGUL</tt> and
<tt>EGUF</tt> respectively if <tt>LINR</tt> is set to <tt>"LINEAR"</tt>.
Analog output records never write raw values lower than <tt><i>low</i></tt>
or higher than <tt><i>high</i></tt>. If necessary, the raw output value is
rounded to the nearest limit. The default values for <tt><i>low</i></tt>
and <tt><i>high</i></tt> depend on <tt>T=<i>type</i></tt>.
</p>
<p>
If <tt>T=STRING</tt>, <tt>L</tt> means <tt><i>length</i></tt>, not
<tt><i>low</i></tt>. The default value is the length of the <tt>VAL</tt> field.
In the case of the stringin and stringout records, this is 40.
</p>
<p>
<tt>B=<i>bit</i></tt> is only used for bi and bo records to define the bit number
within the data byte, word, or doubleword (depending on <tt>T=<i>type</i></tt>).
Bit number 0 is the least significant bit.
</p>
<a name="stat"><h3>2.1 Connection Status</h3></a>
<pre>
  field (DTYP, "S7plc stat")
  field (INP,  "@<i>name</i>: <i>station_number</i>")
</pre>
<p>
The record value is 1 if a connection to the PLC is established and 0 if not.
Disconnect does not raise an alarm.
</p>

<a name="ai"><h3>2.2 Analog Input</h3></a>
<pre>
  field (DTYP, "S7plc")
  field (INP,  "@<i>name</i>: <i>station_number</i>/<i>offset</i> T=<i>type</i> L=<i>low</i> L=<i>high</i>")
</pre>
<p>
Default is <tt>T=INT16</tt>. Defaults for <tt><i>low</i></tt> and <tt><i>high</i></tt> depend on
<a href="#type"><tt><i>type</i></tt></a>.

</p>
<p>If <tt><i>type</i></tt> is an integer type, the
PV is read into <tt>RVAL</tt>. If <tt>LINR="LINEAR"</tt>, then <tt>RVAL</tt>
is converted to <tt>VAL</tt> depending on <tt><i>low</i></tt>,
<tt><i>high</i></tt>, <tt>EGUL</tt>, and <tt>EGUF</tt>:
<tt>RVAL=<i>low</i></tt> converts to <tt>VAL=EGUL</tt> and
<tt>RVAL=<i>high</i></tt> converts to <tt>VAL=EGUF</tt>.
</p>
<p>If <tt><i>type</i></tt> is <tt>FLOAT</tt> or <tt>DOUBLE</tt>, the PV is
read into <tt>VAL</tt> and no conversion takes place.
</p>
<p>
<tt>T=STRING</tt> is not valid for ai records.
</p>

<a name="ao"><h3>2.3 Analog Output</h3></a>
<pre>
  field (DTYP, "S7plc")
  field (OUT,  "@<i>name</i>: <i>station_number</i>/<i>offset</i> T=<i>type</i> L=<i>low</i> L=<i>high</i>")
</pre>
<p>
Default is <tt>T=INT16</tt>. Defaults for <tt><i>low</i></tt> and <tt><i>high</i></tt> depend on
<a href="#type"><tt><i>type</i></tt></a>.
</p>
<p>If <tt><i>type</i></tt> is an integer type, <tt>RVAL</tt> is written to
the PV. If <tt>LINR="LINEAR"</tt>, then <tt>VAL</tt> is converted to
<tt>RVAL</tt> depending on <tt><i>low</i></tt>,
<tt><i>high</i></tt>, <tt>EGUL</tt>, and <tt>EGUF</tt>:
<tt>VAL=EGUL</tt> converts to <tt>RVAL=<i>low</i></tt> and
<tt>VAL=EGUF</tt> converts to <tt>RVAL=<i>high</i></tt>.
If <tt>RVAL</tt> is higher than <tt><i>high</i></tt> or lower than
<tt><i>low</i></tt>, the value is rounded to the nearest limit.
</p>
<p>If <tt><i>type</i></tt> is <tt>FLOAT</tt> or <tt>DOUBLE</tt>, <tt>VAL</tt>
is written to the PV and no conversion takes place.
</p>
<p>
<tt>T=STRING</tt> is not valid for ao records.
</p>

<a name="bi"><h3>2.4 Binary Input</h3></a>
<pre>
  field (DTYP, "S7plc")
  field (INP,  "@<i>name</i>: <i>station_number</i>/<i>offset</i> T=<i>type</i> B=<i>bit</i>")
</pre>
<p>
Default is <tt>T=INT16 B=0</tt>.
</p>
<p>
Depending on <tt><i>type</i></tt>, <tt><i>bit</i></tt> can vary from 0 to 7,
15, or 31. Bit 0 is the least significant bit.
</p>
<p>The PV is read to <tt>RVAL</tt> and masked with
2<sup><tt><i>bit</i></tt></sup>. <tt>VAL</tt> is 1 if <tt>RVAL</tt> is not 0.
</p>
<p>
<tt>T=STRING</tt>, <tt>FLOAT</tt> or <tt>DOUBLE</tt> are not valid
for bi records. Signed or unsigned types are equivalent.
</p>

<a name="bo"><h3>2.5 Binary Output</h3></a>
<pre>
  field (DTYP, "S7plc")
  field (OUT,  "@<i>name</i>: <i>station_number</i>/<i>offset</i> T=<i>type</i> B=<i>bit</i>")
</pre>
<p>
Default is <tt>T=INT16 B=0</tt>.
</p>
<p>
Depending on <tt><i>type</i></tt>, <tt><i>bit</i></tt> can vary from 0 to 7,
15, or 31. Bit 0 is the least significant bit.
</p>
<p>If <tt>VAL</tt> is not 0, then <tt>RVAL</tt> is set to
2<sup><tt><i>bit</i></tt></sup>, else <tt>RVAL</tt> is set to 0.
Only the referenced bit of the PV is changed while all other bits remain
untouched. Thus, other bo records can refer to different bits of the same PV.
</p>
<p>
<tt>T=STRING</tt>, <tt>FLOAT</tt> or <tt>DOUBLE</tt> are not valid
for bo records. Signed or unsigned types are equivalent.
</p>

<a name="mbbi"><h3>2.6 Multibit Binary Input</h3></a>
<pre>
  field (DTYP, "S7plc")
  field (INP,  "@<i>name</i>: <i>station_number</i>/<i>offset</i> T=<i>type</i>")
</pre>
<p>
Default is <tt>T=INT16</tt>.
</p>
<p>The PV is read to <tt>RVAL</tt>, shifted right by <tt>SHFT</tt> bits and
masked with <tt>NOBT</tt> bits. Valid values for <tt>NOBT</tt> and
<tt>SHFT</tt> depend on <tt><i>type</i></tt>: <tt>NOBT</tt>+<tt>SHFT</tt> must
not exceed the number of bits of <tt><i>type</i></tt>.
<p>
<tt>T=STRING</tt>, <tt>FLOAT</tt> or <tt>DOUBLE</tt> are not valid
for mbbi records. Signed or unsigned types are equivalent.
</p>

<a name="mbbo"><h3>2.7 Multibit Binary Output</h3></a>
<pre>
  field (DTYP, "S7plc")
  field (OUT,  "@<i>name</i>: <i>station_number</i>/<i>offset</i> T=<i>type</i>")
</pre>
<p>
Default is <tt>T=INT16</tt>.
</p>
<p>RVAL is masked with <tt>NOBT</tt> bits, shifted left by <tt>SHFT</tt> bits
and written to the PV. Valid values for <tt>NOBT</tt> and <tt>SHFT</tt> depend
on <tt><i>type</i></tt>: <tt>NOBT</tt>+<tt>SHFT</tt> must not exceed the
number of bits of <tt><i>type</i></tt>.
</p>
Only the referenced <tt>NOBT</tt> bits of the PV are changed. All other bits
remain untouched. Thus, bo records or other mbbo records can refer to different
bits of the same PV.
</p>
<p>
<tt>T=STRING</tt>, <tt>FLOAT</tt> or <tt>DOUBLE</tt> are not valid
for mbbo records. Signed or unsigned types are equivalent.
</p>

<a name="mbbiDirect"><h3>2.8 Multibit Binary Input Direct</h3></a>
<pre>
  field (DTYP, "S7plc")
  field (INP,  "@<i>name</i>: <i>station_number</i>/<i>offset</i> T=<i>type</i>")
</pre>
<p>
Default is <tt>T=INT16</tt>.
</p>
<p>The PV is read to <tt>VAL</tt>, shifted right by <tt>SHFT</tt> bits and
masked with <tt>NOBT</tt> bits. Valid values for <tt>NOBT</tt> and
<tt>SHFT</tt> depend on <tt><i>type</i></tt>: <tt>NOBT</tt>+<tt>SHFT</tt> must
not exceed the number of bits of <tt><i>type</i></tt>.
<p>
<tt>T=STRING</tt>, <tt>FLOAT</tt> or <tt>DOUBLE</tt> are not valid
for mbbiDirect records. Signed or unsigned types are equivalent.
</p>

<a name="mbboDirect"><h3>2.9 Multibit Binary Output Direct</h3></a>
<pre>
  field (DTYP, "S7plc")
  field (OUT,  "@<i>name</i>: <i>station_number</i>/<i>offset</i> T=<i>type</i>")
</pre>
<p>
Default is <tt>T=INT16</tt>.
</p>
<p>VAL is masked with <tt>NOBT</tt> bits, shifted left by <tt>SHFT</tt> bits
and written to the PV. Valid values for <tt>NOBT</tt> and <tt>SHFT</tt> depend
on <tt><i>type</i></tt>: <tt>NOBT</tt>+<tt>SHFT</tt> must not exceed the
number of bits of <tt><i>type</i></tt>.
</p>
Only the referenced <tt>NOBT</tt> bits of the PV are changed. All other bits
remain untouched. Thus, bo records, mbbo records or other mbboDirect records
can refer to different bits of the same PV.
</p>
<p>
<tt>T=STRING</tt>, <tt>FLOAT</tt> or <tt>DOUBLE</tt> are not valid
for mbboDirect records. Signed or unsigned types are equivalent.
</p>

<a name="longin"><h3>2.10 Long Input</h3></a>
<pre>
  field (DTYP, "S7plc")
  field (INP,  "@<i>name</i>: <i>station_number</i>/<i>offset</i> T=<i>type</i>")
</pre>
<p>
Default is <tt>T=INT16</tt>.
</p>
<p>
The PV is read to <tt>VAL</tt>. Depending on <tt><i>type</i></tt>,
<tt>VAL</tt> is sign extended or zero extended.
</p>
<p>
<tt>T=STRING</tt>, <tt>FLOAT</tt> or <tt>DOUBLE</tt> are not valid
for longin records.
</p>

<a name="longout"><h3>2.11 Long Output</h3></a>
<pre>
  field (DTYP, "S7plc")
  field (OUT,  "@<i>name</i>: <i>station_number</i>/<i>offset</i> T=<i>type</i>")
</pre>
<p>
Default is <tt>T=INT16</tt>.
</p>
<p>
Depending on <tt><i>type</i></tt>, the least significant 1, 2, or 4 bytes
of <tt>VAL</tt> are written to the PV.
</p>
<p>
<tt>T=STRING</tt>, <tt>FLOAT</tt> or <tt>DOUBLE</tt> are not valid
for longout records.
</p>

<a name="stringin"><h3>2.12 String Input</h3></a>
<pre>
  field (DTYP, "S7plc")
  field (INP,  "@<i>name</i>: <i>station_number</i>/<i>offset</i> T=<i>type</i> L=<i>length</i>")
</pre>
<p>
Default and only valid <tt><i>type</i></tt> is <tt>T=STRING</tt>. Default
<tt><i>length<i></tt> is 40.
</p>
<p>
<tt><i>length<i></tt> bytes are read from the PV to <tt>VAL</tt> and null
terminated. Thus, the effective string length is maximal
<tt><i>length<i></tt>-1 bytes.
</p>

<a name="stringout"><h3>2.13 String Output</h3></a>
<pre>
  field (DTYP, "S7plc")
  field (OUT,  "@<i>name</i>: <i>station_number</i>/<i>offset</i> T=<i>type</i> L=<i>length</i>")
</pre>
<p>
Default and only valid <tt><i>type</i></tt> is <tt>T=STRING</tt>. Default
<tt><i>length<i></tt> is 40.
</p>
<p>
<tt><i>length<i></tt> bytes are written from <tt>VAL</tt> to the PV.
If the actual string length is shorter than <tt><i>length<i></tt>,
the remaining space is filled with null bytes.
</p>

<a name="waveform"><h3>2.14 Waveform</h3></a>
<pre>
  field (DTYP, "S7plc")
  field (INP,  "@<i>name</i>: <i>station_number</i>/<i>offset</i> T=<i>type</i> L=<i>length</i>")
</pre>
<p>
The default <tt><i>type</i></tt> depends on <tt>FTVL</tt>.
<tt><i>length</i></tt> is only used if <tt>T=STRING</tt> and defaults
to <tt>NELM</tt>.
</p>
<p>
<tt>NELM</tt> elements are read from the PV to <tt>VAL</tt>.
</p>
<p>
The special <tt><i>type</i></tt> <tt>T=TIME</tt> is supported for waveforms
records only. <tt>FTVL</tt> must be <tt>"CHAR"</tt> or <tt>"UCHAR"</tt> and
<tt>NELM</tt> should be <tt>"8"</tt>. Eight bytes are converted from BCD
(binary coded decimal) to 8 bit integer values in the range from 0 to 99 each.
This type is intended to transfer BCD coded real time clock timestamps.
</p>
<p>
If <tt>T=STRING</tt>, <tt>FTVL</tt> must be <tt>"CHAR"</tt> or
<tt>"UCHAR"</tt>. <tt><i>length</i></tt> characters are read to <tt>VAL</tt>.
<tt><i>length</i></tt> must not exceed <tt>NELM</tt>.
</p>
<p>
<tt>FTVL="STRING"</tt> is not supported.
</p>

<h2>3 Driver Functions</h2>
<p>
New record types can be supported with calls to the driver functions.
</p>
<ul>
<pre>
s7plcStation *s7plcOpen (char *name, unsigned int stationNumber);

int s7plcRead (s7plcStation *station, unsigned int offset, unsigned int dleng, void* pdata);

int s7plcReadArray (s7plcStation *station, unsigned int offset, unsigned int dleng, unsigned int nelem, void* pdata);

int s7plcWrite (s7plcStation *station, unsigned int offset, unsigned int dleng, void* pdata);

int s7plcWriteMasked (s7plcStation *station, unsigned int offset, unsigned int dleng, void* pdata, void* pmask);

int s7plcWriteArray (s7plcStation *station, unsigned int offset, unsigned int dleng, unsigned int nelem, void* pdata);

int s7plcWriteMaskedArray (s7plcStation *station, unsigned int offset, unsigned int dleng, unsigned int nelem, void* pdata, void* pmask);
</pre>
</ul>
<p>
<tt>s7plcRead()</tt>, <tt>s7plcWrite()</tt>,
<tt>s7plcWriteMasked()</tt>, and <tt>s7plcWriteArray()</tt>
are actually macros for
<tt>s7plcReadArray()</tt> and <tt>s7plcWriteMaskedArray()</tt> with
<tt>nelem=1</tt> and/or <tt>mask=NULL</tt>.
</p>
<p>
<tt>station</tt> is a handle previously obtained by a call to
<tt>s7plcOpen()</tt>.
</p>
<p>
<tt>offset</tt> is the byte offset of the PV relative
to the beginning to the data block.
</p>
<p>
<tt>dleng</tt> is the length of data type in bytes. If the endianess of the PLC
differs fron the ioc, the byte order of the <tt>dleng</tt> bytes is swapped.
</p>
<p>
<tt>nelem</tt> is the number of elements in an array.
</p>
<p>
<tt>pdata</tt> is a pointer to a buffer of <tt>nelem</tt>*<tt>dleng</tt> bytes.
PVs are read to or written from this buffer.
</p>
<p>
<tt>mask</tt> is a pointer to a bitmask of <tt>dleng</tt> bytes. Only those
bits are written where the mask contains 1 bits. All other bits remain
untouched.
</p>

<a name="end"></a>
</body>
</html>
